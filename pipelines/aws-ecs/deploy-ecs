import groovy.json.JsonOutput
import groovy.json.JsonSlurperClassic
import java.util.regex.Pattern
def wsVersions = ['n/a']
def adminVersions = ['n/a']
def centralVersions = ['n/a']
def envs = ['n/a'] 
def choiceArray = []
def albName = 'T6-DEV-ALB'
def albArn = ''
def listenerArn = ''
def taskDefinitions = [:]  // Declare taskDefinitions here
def targetGroups = [:]  // Declare targetGroups
def listenerPort = 443
def handleError(message, exitPipeline = true) {
    echo "ERROR: ${message}"
    currentBuild.result = 'FAILURE'
    if (exitPipeline) {
        error(message)
    }
}
def skipRemainingStages = false
def admin_combine_env
def central_combine_env
def ws_combine_env
def readFileContent(String file) {
    return readFile(file).trim()
}

def parseEnvVariables(String envVars) {
    def envList = []
    envVars.split('\n').each { line ->
        if (!line.startsWith("#") && line.contains('=')) {
            def (key, value) = line.split('=', 2)
            envList << [name: key.trim(), value: value.trim()]
        }
    }
    return envList // Corrected return statement
}
// A helper method to fetch image tags from AWS ECR
def fetchImageTags(String repositoryName) {
    def command = "aws ecr list-images --region us-east-1 --repository-name ${repositoryName} --output json"
    def output = sh(script: command, returnStdout: true).trim()
    def json = new JsonSlurperClassic().parseText(output)
    def tags = json.imageIds.collect { it.imageTag }.findAll { it != null }
    return tags.isEmpty() ? ['n/a'] : tags
}

def getLogConfiguration(String serverName, String containerType) {
    return [
        logDriver: "awslogs",
        options: [
            "awslogs-group": "T6-Devops-Migration-DEV-LOGS",
            "awslogs-region": "${AWS_REGION}",
            "awslogs-stream-prefix": "${serverName}/${containerType}"
        ]
    ]
}

def fetchHighestPriority(String listenerArn) {
    def command = "aws elbv2 describe-rules --listener-arn ${listenerArn} --region ${AWS_REGION} --query 'Rules[].Priority' --output text"
    def output = sh(script: command, returnStdout: true).trim()
    
    // Filter out 'default' and any non-integer values
    def priorities = output.split("\\s+").findAll { it.isInteger() }.collect { it as Integer }

    return priorities ? priorities.max() : 0
}
// Helper method to check if a string is an integer
String.metaClass.isInteger = {
    delegate ==~ /\d+/
}

def updateTaskDefinition(containerConfigs) {
    TASKFAMILY = "${params.SERVER_NAME}-task"
    def cpu, memory

    // Set CPU and Memory based on resource usage
    switch (resourceUsage) {
        case 'low':
            cpu = 1024
            memory = 2048
            break
        case 'medium':
            cpu = 2048
            memory = 4096
            break
        case 'high':
            cpu = 4096
            memory = 8192
            break
        default:
            echo "Invalid resource usage selected. Using default values (low)."
            cpu = 1024
            memory = 2048
    }

    def containerDefinitions = containerConfigs.collect { config ->
        def logConfig = JsonOutput.toJson(config.logConfiguration).toString()
        """
        {
            "name": "${params.SERVER_NAME}-${config.containerType}",
            "image": "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${config.repositoryName}:${config.imageVersion}",
            "memoryReservation": 256,
            "essential": true,
            "portMappings": [{
                "containerPort": ${config.containerport},
                "hostPort": ${config.containerport}
            }],
            "entryPoint": [],
            "command": [],
            "environment": ${JsonOutput.toJson(config.taskDefEnv)},
            "logConfiguration": ${logConfig}
        }
        """
    }.join(',') 
    echo "Container Definitions JSON: ${containerDefinitions}"
    def taskDefArn = sh(script: """
        aws ecs register-task-definition \
            --region ${AWS_REGION} \
            --family ${TASKFAMILY} \
            --container-definitions '[${containerDefinitions}]' \
            --requires-compatibilities FARGATE \
            --cpu ${cpu} \
            --memory ${memory} \
            --task-role-arn arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole \
            --execution-role-arn arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole \
            --network-mode awsvpc \
            --output json \
            --query 'taskDefinition.taskDefinitionArn'
    """, returnStdout: true).trim()
    echo "ECS Task Definition ARN: ${taskDefArn}"
    return taskDefArn
}
node('AWS-AGENT1') {
    script {
        // AWS credentials binding
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
            // The AWS CLI commands to fetch the image tags
            wsVersions = fetchImageTags('t6-webservice')
            adminVersions = fetchImageTags('t6-admin')
            centralVersions = fetchImageTags('t6-central')
        }
        // Set the environment if it's not the default value
        if ("${params.environment}" != 'n/a') {
            envs = [params.environment]
        }
    }
}

pipeline {
    agent {
        label 'aws-agent1'
    }
    parameters {
        choice(name: 'parameterize', choices: ['Yes', 'No'], description: "Run a parameterization dry run?")
        string(name: 'SERVER_NAME', defaultValue: 'null', description: 'Give Server Name e.g. dev1, node20')
        choice(name: 'wsVersion', choices: wsVersions, description: 'T6 Webservice version')
        choice(name: 'adminVersion', choices: adminVersions, description: 'T6 Admin version')
        choice(name: 'centralVersion', choices: ['NONE'] + centralVersions, description: 'T6 Central version (OPTIONAL)')
        choice(name: 'VALIDATE_CONF', choices: ['yes', 'no'], description: 'Validate configuration option')
        choice(name: 'databaseType', choices: ['MSSQL', 'PSQL'], description: 'Select Database Type')
        choice(name: 'resourceUsage', choices: ['low', 'medium', 'high'], description: 'low (CPU: 1GB, Memory: 2GB), medium (CPU: 2GB, Memory: 4GB), high (CPU: 4GB, Memory: 8GB)')
        text(name: 'userComments', defaultValue: '', description: 'Provide the purpose of the build and metadata version used')
    }
    environment {
        AWS_CREDENTIALS_Jenkins = credentials('aws-creds')
        AWS_REGION = "region"
        AWS_ACCOUNT_ID = 'account'
        ECS_CLUSTER_NAME = 't6-ecs-dev'
        VPC_ID = 'vpc-0dc9dcbf253012078'
        PRIVATE_SUBNET_ID = 'subnetid'
        SUBNETS = "subnetids"
        SECURITY_GROUP_ID = 'sg-'
        SECURITY_GROUP_ECS = 'sg-'
        TG_PATH_ADMIN = "${SERVER_NAME}/admin"
        TG_PATH_CENTRAL = "${SERVER_NAME}/central"
        TG_PATH_WS = "${SERVER_NAME}/ws"
        DIRECTORY = 'Deploy-DEV'
        TASKFAMILY = ''     
    }
    stages {
        stage('Parameterizing Job') {
            steps {
                script {
                    if ("${params.parameterize}" == "Yes") {
                        currentBuild.result = 'ABORTED'
                        error('DRY RUN COMPLETED. JOB PARAMETERIZED.')
                    }
                }
            }
        }
        stage('Delete Existing Resources') {
            steps {
                script {
                    if (params.deleteResources == 'Yes') {
                        echo "Deleting existing resources..."

                        // Delete ECS service
                        def ecsServiceName = "${params.SERVER_NAME}-service"

                        // Check if the service exists
                        def serviceExists = sh(script: """
                            aws ecs describe-services --cluster ${ECS_CLUSTER_NAME} --services ${ecsServiceName} --region ${AWS_REGION} --query 'services[0].status' --output text
                        """, returnStdout: true).trim()
                        //def updateServiceResult
                        if (serviceExists != 'ACTIVE') {
                            echo "ECS service ${ecsServiceName} does not exist. Nothing to delete."
                            // Abort the pipeline intentionally
                            currentBuild.result = 'ABORTED'
                            error("Pipeline aborted as no resources exist to be deleted.")
                        } else {
                            // Update service to have a desired count of 0
                            sh """
                                aws ecs update-service \
                                    --region ${AWS_REGION} \
                                    --cluster ${ECS_CLUSTER_NAME} \
                                    --service ${ecsServiceName} \
                                    --desired-count 0
                            """
                            // Get task ARNs
                            def taskArns = sh(script: """
                                aws ecs list-tasks \
                                    --region ${AWS_REGION} \
                                    --cluster ${ECS_CLUSTER_NAME} \
                                    --service-name ${ecsServiceName} \
                                    --query 'taskArns' \
                                    --output text
                            """, returnStdout: true).trim()
                            // Stop each task
                            if (taskArns) {
                                taskArns.split().each { taskArn ->
                                    def taskId = taskArn.tokenize('/').last()
                                    sh """
                                        aws ecs stop-task \
                                            --region ${AWS_REGION} \
                                            --cluster ${ECS_CLUSTER_NAME} \
                                            --task ${taskId}
                                    """
                                }
                                // Wait for all tasks to be stopped
                                echo "Waiting for tasks to be stopped..."
                                sh """
                                    aws ecs wait tasks-stopped \
                                        --region ${AWS_REGION} \
                                        --cluster ${ECS_CLUSTER_NAME} \
                                        --tasks ${taskArns}
                                """
                            }
                            // Delete ECS service
                            echo "Deleting existing ECS service..."
                            sh """
                                aws ecs delete-service \
                                    --region ${AWS_REGION} \
                                    --cluster ${ECS_CLUSTER_NAME} \
                                    --service ${ecsServiceName} \
                                    --force
                            """
                            // Wait for Service to Drain
                            sh """
                                aws ecs wait services-inactive \
                                    --region ${AWS_REGION} \
                                    --cluster ${ECS_CLUSTER_NAME} \
                                    --services ${ecsServiceName} 
                            """
                            echo "Services have stabilized."

                            skipRemainingStages = true
                        }
                    } else {
                        echo "Skipping deletion as deleteResources is not set to 'Yes'."
                    }
                }
            }
        }

        stage('Get Ports') {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                script {
                    def workspacePath = env.WORKSPACE
                    def adminFilePath = "${workspacePath}/CONFIGS/admin_params.env"
                    def wsFilePath = "${workspacePath}/CONFIGS/webservice_params.env"
                    def centralFilePath = "${workspacePath}/CONFIGS/central_params.env"
                    //Read the admin port
                    if (fileExists(adminFilePath)) {
                        env.CONTAINER_PORT_ADMIN = sh(
                            script: "grep SERVER_PORT ${adminFilePath} | cut -d'=' -f2",
                            returnStdout: true
                        ).trim()
                    }
                    // Read the webservice port
                    if (fileExists(wsFilePath)) {
                        env.CONTAINER_PORT_WS = sh(
                            script: "grep SERVER_PORT ${wsFilePath} | cut -d'=' -f2",
                            returnStdout: true
                        ).trim()
                    }
                    // Read the central port
                    if (fileExists(centralFilePath)) {
                        env.CONTAINER_PORT_CENTRAL = sh(
                            script: "grep SERVER_PORT ${centralFilePath} | cut -d'=' -f2",
                            returnStdout: true
                        ).trim()
                    } 
                }
            }
        }
        stage('Check and Create ECS Cluster') {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                script {
                    def clusterStatus = sh(script: """
                        aws ecs describe-clusters --cluster ${ECS_CLUSTER_NAME} --region ${AWS_REGION} --query 'clusters[0].status' --output text
                    """, returnStdout: true).trim()

                    echo "Cluster Status: ${clusterStatus}"

                    if (clusterStatus != 'ACTIVE') {
                        echo "The referenced cluster is inactive. Creating ECS Cluster..."
                        sh "aws ecs create-cluster --cluster-name ${ECS_CLUSTER_NAME} --region ${AWS_REGION}"
                    } else {
                        echo "ECS Cluster already exists and is active."
                    }
                }
            }
        }
        stage('Check and Create ALB') {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                script {                    
                    def albExists = sh(script: """
                        aws elbv2 describe-load-balancers --names ${albName} --region ${AWS_REGION} --query 'LoadBalancers' --output text
                    """, returnStatus: true) == 0   
                    echo "ALB Exists?: ${albExists}"
                    if (!albExists) {
                        albArn = sh(script: """
                        aws elbv2 create-load-balancer \
                            --name ${albName} \
                            --subnets ${SUBNETS} \
                            --security-groups ${SECURITY_GROUP_ECS} \
                            --region ${AWS_REGION} \
                            --output text \
                            --query 'LoadBalancers[0].LoadBalancerArn' \
                            --scheme internal
                    """, returnStdout: true).trim()
                    }
                    else {
                        albArn = sh(script: """
                        aws elbv2 describe-load-balancers --names ${albName} --region ${AWS_REGION} --query 'LoadBalancers[0].LoadBalancerArn' --output text
                    """, returnStdout: true).trim()
                    }

                    // Check if the listener exists
                    def listenerExists = sh(script: """
                        aws elbv2 describe-listeners --load-balancer-arn ${albArn} --region ${AWS_REGION} --query 'Listeners[0].ListenerArn' --output text
                    """, returnStdout: true).trim()

                    echo "ListenerArnOutput: ${listenerExists}"
                    
                    if (listenerExists) {
                        // Listener exists, get its ARN
                        listenerArn = listenerExists
                        echo "Listener Already Exists. ARN: ${listenerArn}"
                    } else {
                        // Create Listener
                        listenerArn = sh(script: """
                        aws elbv2 create-listener \
                            --load-balancer-arn ${albArn} \
                            --protocol HTTP \
                            --port ${listenerPort} \
                            --default-actions Type=fixed-response,FixedResponseConfig={ContentType=text/plain,StatusCode=200,MessageBody=OK} \
                            --region ${AWS_REGION} \
                            --output text \
                            --query 'Listeners[0].ListenerArn'
                    """, returnStdout: true).trim()

                    echo "Listener Created. ARN: ${listenerArn}"
                    }

                }
            }
        }
        //admin_params
        stage('Update JAVA_OPTS') {
            steps {
                script {
                    dir("./CONFIGS/") {
                        def filePath_web = 'webservice_params.env'
                        def filePath_admin = 'admin_params.env'
                        def fileContent_web = readFile(filePath_web)
                        def fileContent_admin = readFile(filePath_admin)
                        
                        if (params.VALIDATE_CONF == 'yes') {
                            if (!fileContent_web.contains("-Dt6.validate.configuration=true")) {
                                fileContent_web = fileContent_web.replaceAll("(JAVA_OPTS=.*?)(\$)", "\$1 -Dt6.validate.configuration=true\$2")
                            }
                            if (!fileContent_admin.contains("-Dt6.validate.configuration=true")) {
                                fileContent_admin = fileContent_admin.replaceAll("(JAVA_OPTS=.*?)(\$)", "\$1 -Dt6.validate.configuration=true\$2")
                            }
                        } else {
                            fileContent_web = fileContent_web.replaceAll(" -Dt6.validate.configuration=true", "")
                            fileContent_admin = fileContent_admin.replaceAll(" -Dt6.validate.configuration=true", "")
                        }
                        writeFile file: filePath_web, text: fileContent_web
                        writeFile file: filePath_admin, text: fileContent_admin
                        echo "Updated webservice_params.env:\n${fileContent_web}"
                        echo "Updated admin_params.env:\n${fileContent_admin}"
                    }
                }
            }
        }
        stage('Pull Environment Variables from Jenkins Workspace') {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                script {                  
                    def workspacePath = env.WORKSPACE
                    def SPRING_DATABASE_ADMIN_WS = ''
                    def SPRING_DATABASE_CENTRAL = ''
                    echo "Database Type: ${params.databaseType}"

                    if (params.databaseType == 'MSSQL') {
                        SPRING_DATABASE_ADMIN_WS = 'jdbc:sqlserver://t6-internal-rds.chlyypksqpgf.us-east-1.rds.amazonaws.com:1433;databaseName=INPUT_SERVER_VALUE;trustServerCertificate=true;'
                        SPRING_DATABASE_CENTRAL = 'jdbc:sqlserver://t6-internal-rds.chlyypksqpgf.us-east-1.rds.amazonaws.com:1433;databaseName=central_INPUT_SERVER_VALUE;trustServerCertificate=true;'
                    } else {
                        SPRING_DATABASE_ADMIN_WS = 'jdbc:postgresql://t6-dev-rds-psql.chlyypksqpgf.us-east-1.rds.amazonaws.com:5432/INPUT_SERVER_VALUE?currentSchema=dbo'
                        SPRING_DATABASE_CENTRAL = 'jdbc:postgresql://t6-dev-rds-psql.chlyypksqpgf.us-east-1.rds.amazonaws.com:5432/central_INPUT_SERVER_VALUE?currentSchema=dbo'
                    }

                    // Read the file into a variable
                    def fileContent_admin = readFile './CONFIGS/admin_params.env'
                    def fileContent_central = readFile './CONFIGS/central_params.env'
                    def fileContent_central_main = readFile './CONFIGS/central_main_params.env'
                    def fileContent_ws = readFile './CONFIGS/webservice_params.env'

                  
                    fileContent_admin = fileContent_admin.replaceAll('DATABASE_PLACEHOLDER', SPRING_DATABASE_ADMIN_WS)
                    fileContent_central = fileContent_central.replaceAll('DATABASE_PLACEHOLDER', SPRING_DATABASE_CENTRAL)
                    fileContent_ws = fileContent_ws.replaceAll('DATABASE_PLACEHOLDER', SPRING_DATABASE_ADMIN_WS)

                    // Replace the placeholder with the SERVER_NAME parameter
                    fileContent_admin = fileContent_admin.replaceAll('INPUT_SERVER_VALUE', params.SERVER_NAME)
                    fileContent_central = fileContent_central.replaceAll('INPUT_SERVER_VALUE', params.SERVER_NAME)
                    fileContent_ws = fileContent_ws.replaceAll('INPUT_SERVER_VALUE', params.SERVER_NAME)


                    
                    writeFile file: './CONFIGS/admin_params.env', text: fileContent_admin
                    writeFile file: './CONFIGS/central_params.env', text: fileContent_central
                    writeFile file: './CONFIGS/webservice_params.env', text: fileContent_ws


                    // Define paths for environment variable files
                    def adminEnvFile = "${workspacePath}/CONFIGS/admin_params.env"
                    def centralEnvFile = "${workspacePath}/CONFIGS/central_params.env"
                    def wsEnvFile = "${workspacePath}/CONFIGS/webservice_params.env"
                    
                    def configsetEnvFile = "${workspacePath}/configset/Standard/configset.env"
                    def credentialsEnvFile = "/opt/t6/credentials/credentials.env"

                    // Combine contents of environment variable files
                    ws_combine_env = readFileContent(credentialsEnvFile) + "\n" + readFileContent(wsEnvFile) + "\n" + readFileContent(configsetEnvFile)
                    admin_combine_env = readFileContent(credentialsEnvFile) + "\n" + readFileContent(adminEnvFile) + "\n" + readFileContent(configsetEnvFile)
                    central_combine_env = readFileContent(centralEnvFile)

              
                }
            }
        }

        stage('Create ECS Task Definitions and Services') {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                script {
                    def containerConfigs = []
                    if ("${params.centralVersion}" != 'NONE') {
                        containerConfigs = [
                            [
                                containerType: "admin",
                                repositoryName: "t6-admin",
                                imageVersion: "${params.adminVersion}",
                                taskDefEnv: parseEnvVariables(admin_combine_env),
                                containerport: "${env.CONTAINER_PORT_ADMIN}",
                                logConfiguration: getLogConfiguration("${params.SERVER_NAME}", "admin")
                            ],
                            [
                                containerType: "central",
                                repositoryName: "t6-central",
                                imageVersion: "${params.centralVersion}",
                                taskDefEnv: parseEnvVariables(central_combine_env),
                                containerport: "${env.CONTAINER_PORT_CENTRAL}",
                                logConfiguration: getLogConfiguration("${params.SERVER_NAME}", "central")

                            ],
                            [
                                containerType: "ws",
                                repositoryName: "t6-webservice",
                                imageVersion: "${params.wsVersion}",
                                taskDefEnv: parseEnvVariables(ws_combine_env),
                                containerport: "${env.CONTAINER_PORT_WS}",
                                logConfiguration: getLogConfiguration("${params.SERVER_NAME}", "ws")

                            ]
                        ]
                    }
                    else {
                        containerConfigs = [
                        [
                            containerType: "admin",
                            repositoryName: "t6-admin",
                            imageVersion: "${params.adminVersion}",
                            taskDefEnv: parseEnvVariables(admin_combine_env),
                            containerport: "${env.CONTAINER_PORT_ADMIN}",
                            logConfiguration: getLogConfiguration("${params.SERVER_NAME}", "admin")
                        ],
                        [
                            containerType: "ws",
                            repositoryName: "t6-webservice",
                            imageVersion: "${params.wsVersion}",
                            taskDefEnv: parseEnvVariables(ws_combine_env),
                            containerport: "${env.CONTAINER_PORT_WS}",
                            logConfiguration: getLogConfiguration("${params.SERVER_NAME}", "ws")

                        ]
                    ]
                    }
                    echo "Container Configs set"
                    def taskDefArn = updateTaskDefinition(containerConfigs)                   
                    echo "ECS Task Definition ARN: ${taskDefArn}"
                    // Define a map to store listener port for each container type
                    def containerPorts = [
                        admin: "${env.CONTAINER_PORT_ADMIN}",
                        ws: "${env.CONTAINER_PORT_WS}",
                        central: "${env.CONTAINER_PORT_CENTRAL}"
                    ]
                    // Create Target Group and Listener Rules for Each Container Type
                    def highestPriority = fetchHighestPriority(listenerArn)
                    def newPriority = highestPriority + 1

                    def containerTypes = ["admin", "ws"]
                    if ("${params.centralVersion}" != 'NONE') {
                        containerTypes.add("central")
                    }   

                    for (def containerType in containerTypes) {
                        def targetGroupName = "${params.SERVER_NAME}-${containerType}-target-group"
                        def containerPort = containerPorts[containerType]                       
                        // Check if the target group already exists
                        def targetGroupExists = sh(script: """
                            aws elbv2 describe-target-groups \
                                --names ${targetGroupName} \
                                --region ${AWS_REGION} \
                                --query 'TargetGroups' \
                                --output text
                        """, returnStatus: true) == 0

                        // Create the target group if it doesn't exist
                        if (!targetGroupExists) {
                            def targetGroupArn = sh(script: """
                                aws elbv2 create-target-group \
                                    --name ${targetGroupName} \
                                    --protocol HTTP \
                                    --port ${listenerPort} \
                                    --target-type ip \
                                    --vpc-id ${VPC_ID} \
                                    --region ${AWS_REGION} \
                                    --matcher HttpCode=200 \
                                    --health-check-protocol HTTP \
                                    --health-check-path /${params.SERVER_NAME}/${containerType}/settings \
                                    --health-check-port ${containerPort} \
                                    --health-check-interval-seconds 180 \
                                    --health-check-timeout-seconds 120 \
                                    --health-check-timeout-seconds 5 \
                                    --unhealthy-threshold-count 2 \
                                    --output text \
                                    --query 'TargetGroups[0].TargetGroupArn'
                            """, returnStdout: true).trim()

                            echo "Target Group ARN for ${containerType}: ${targetGroupArn}"
                            targetGroups[containerType] = targetGroupArn
                        } else {
                            // Retrieve the existing target group ARN
                            def existingTargetGroupArn = sh(script: """
                                aws elbv2 describe-target-groups \
                                    --names ${targetGroupName} \
                                    --region ${AWS_REGION} \
                                    --query 'TargetGroups[0].TargetGroupArn' \
                                    --output text
                            """, returnStdout: true).trim()

                            echo "Target group already exists for ${containerType}. Using existing Target Group ARN: ${existingTargetGroupArn}"
                            targetGroups[containerType] = existingTargetGroupArn
                            
                        }

                        // Retrieve all rules for the listener
                        def allRules = sh(script: """
                            aws elbv2 describe-rules \
                                --listener-arn ${listenerArn} \
                                --region ${AWS_REGION} \
                                --query 'Rules'
                        """, returnStdout: true).trim()

                        // Check if a rule with the specified conditions already exists
                        def ruleExists = allRules.contains("/${params.SERVER_NAME}/${containerType}*")
                        
                        
                        // Create the rule if it doesn't exist
                        if (!ruleExists) {
                            def targetGroupArn = targetGroups[containerType]
                            sh """
                                aws elbv2 create-rule \
                                    --listener-arn ${listenerArn} \
                                    --conditions Field=path-pattern,Values=/${params.SERVER_NAME}/${containerType}* \
                                    --priority ${newPriority} \
                                    --actions Type=forward,TargetGroupArn=${targetGroupArn} \
                                    --region ${AWS_REGION}
                            """
                            newPriority++ 
                        } else {
                            echo "Rule conditions already exist for ${containerType}. Skipping rule creation."
                            newPriority++ 
                        }
                    }
                    def ecsServiceName = "${params.SERVER_NAME}-service"
                    def containerPortAdmin = "${env.CONTAINER_PORT_ADMIN}"
                    def containerPortCentral = "${env.CONTAINER_PORT_CENTRAL}"
                    def containerPortWS = "${env.CONTAINER_PORT_WS}"
                    // Check if the Service Exists, if Not Create Service. If Yes, Delete and Create Service.
                    def serviceExists = sh(script: """
                        aws ecs describe-services --cluster ${ECS_CLUSTER_NAME} --services ${ecsServiceName} --region ${AWS_REGION} --query 'services[0].status' --output text
                    """, returnStdout: true).trim()
                    //def updateServiceResult
                    if (serviceExists != 'ACTIVE') {
                        echo "Service does not exist. Creating service..."
                        if ("${params.centralVersion}" != 'NONE') {
                            try {
                                sh """
                                    aws ecs create-service \
                                        --region ${AWS_REGION} \
                                        --cluster ${ECS_CLUSTER_NAME} \
                                        --service-name ${ecsServiceName} \
                                        --task-definition ${TASKFAMILY} \
                                        --desired-count 1 \
                                        --launch-type FARGATE \
                                        --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNET_ID}],securityGroups=[${SECURITY_GROUP_ECS}]}" \
                                        --enable-execute-command \
                                        --load-balancers "targetGroupArn=${targetGroups['central']},containerName=${params.SERVER_NAME}-central,containerPort=${containerPortCentral}" "targetGroupArn=${targetGroups['ws']},containerName=${params.SERVER_NAME}-ws,containerPort=${containerPortWS}" "targetGroupArn=${targetGroups['admin']},containerName=${params.SERVER_NAME}-admin,containerPort=${containerPortAdmin}"
                                """
                            } catch (Exception e) {
                                handleError("Failed to create service: ${e.message}")
                            }
                        }
                        else {
                            try {
                                sh """
                                    aws ecs create-service \
                                        --region ${AWS_REGION} \
                                        --cluster ${ECS_CLUSTER_NAME} \
                                        --service-name ${ecsServiceName} \
                                        --task-definition ${TASKFAMILY} \
                                        --desired-count 1 \
                                        --launch-type FARGATE \
                                        --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNET_ID}],securityGroups=[${SECURITY_GROUP_ECS}]}" \
                                        --enable-execute-command \
                                        --load-balancers "targetGroupArn=${targetGroups['ws']},containerName=${params.SERVER_NAME}-ws,containerPort=${containerPortWS}" "targetGroupArn=${targetGroups['admin']},containerName=${params.SERVER_NAME}-admin,containerPort=${containerPortAdmin}"
                                """
                            } catch (Exception e) {
                                handleError("Failed to create service: ${e.message}")
                            }
                        }
                    } else {
                        echo "Service exists. Deleting all tasks and service..."
                        sh """
                              aws ecs update-service \
                                --region ${AWS_REGION} \
                                --cluster ${ECS_CLUSTER_NAME} \
                                --service ${ecsServiceName} \
                                --desired-count 0
                        """
                        def taskArns = sh(script: """
                            aws ecs list-tasks \
                                --region ${AWS_REGION} \
                                --cluster ${ECS_CLUSTER_NAME} \
                                --service-name ${ecsServiceName} \
                                --query 'taskArns' \
                                --output text
                            """, returnStdout: true).trim()
                        // Stop each task
                        if (taskArns) {
                            taskArns.split().each { taskArn ->
                                // Extract the task ID from the task ARN
                                def taskId = taskArn.tokenize('/').last()

                                // Stop the task using the task ID
                                sh """
                                    aws ecs stop-task \
                                        --region ${AWS_REGION} \
                                        --cluster ${ECS_CLUSTER_NAME} \
                                        --task ${taskId}
                                """
                            }
                            // Wait for all tasks to be stopped
                            echo "Waiting for tasks to be stopped..."
                            sh """
                                aws ecs wait tasks-stopped \
                                    --region ${AWS_REGION} \
                                    --cluster ${ECS_CLUSTER_NAME} \
                                    --tasks ${taskArns}
                            """
                        }                      
                        // Delete the service
                        echo "Deleting existing ECS service..."
                        sh """
                            aws ecs delete-service \
                                --region ${AWS_REGION} \
                                --cluster ${ECS_CLUSTER_NAME} \
                                --service ${ecsServiceName} \
                                --force
                        """
                        // Wait for Service to Drain
                        sh """
                            aws ecs wait services-inactive \
                                --region ${AWS_REGION} \
                                --cluster ${ECS_CLUSTER_NAME} \
                                --services ${ecsServiceName} 
                        """
                        echo "Services have stabilized."
                        if ("${params.centralVersion}" != 'NONE') {
                            try {
                                sh """
                                    aws ecs create-service \
                                        --region ${AWS_REGION} \
                                        --cluster ${ECS_CLUSTER_NAME} \
                                        --service-name ${ecsServiceName} \
                                        --task-definition ${TASKFAMILY} \
                                        --desired-count 1 \
                                        --launch-type FARGATE \
                                        --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNET_ID}],securityGroups=[${SECURITY_GROUP_ECS}]}" \
                                        --enable-execute-command \
                                        --load-balancers "targetGroupArn=${targetGroups['central']},containerName=${params.SERVER_NAME}-central,containerPort=${containerPortCentral}" "targetGroupArn=${targetGroups['ws']},containerName=${params.SERVER_NAME}-ws,containerPort=${containerPortWS}" "targetGroupArn=${targetGroups['admin']},containerName=${params.SERVER_NAME}-admin,containerPort=${containerPortAdmin}"
                                """
                            } catch (Exception e) {
                                handleError("Failed to create service: ${e.message}")
                            }
                        }
                        else {
                            try {
                                sh """
                                    aws ecs create-service \
                                        --region ${AWS_REGION} \
                                        --cluster ${ECS_CLUSTER_NAME} \
                                        --service-name ${ecsServiceName} \
                                        --task-definition ${TASKFAMILY} \
                                        --desired-count 1 \
                                        --launch-type FARGATE \
                                        --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNET_ID}],securityGroups=[${SECURITY_GROUP_ECS}]}" \
                                        --enable-execute-command \
                                        --load-balancers "targetGroupArn=${targetGroups['ws']},containerName=${params.SERVER_NAME}-ws,containerPort=${containerPortWS}" "targetGroupArn=${targetGroups['admin']},containerName=${params.SERVER_NAME}-admin,containerPort=${containerPortAdmin}"
                                """
                            } catch (Exception e) {
                                handleError("Failed to create service: ${e.message}")
                            }
                        }
                    }       
                }
            }
        }

        stage('Delay After Deployment') {
            steps {
                script {
                    echo "Delaying for 2 minutes..."
                    sleep(time: 2, unit: 'MINUTES')
                }
            }
        }

        

    }
    post {
        success {
            script {
                slackSend channel: '#backend-releases',
                        color: '#73c990',
                        message: "SUCCESS: Pipeline <${env.BUILD_URL}|${currentBuild.fullDisplayName}> completed.\n" 
                            
               
            }
        }
        
        failure {
            slackSend channel: '#backend-releases',
                    color: '#d54c53',
                    message: "FAILURE: Pipeline <${env.BUILD_URL}|${currentBuild.fullDisplayName}> failed.\n"
        }
    }
}

